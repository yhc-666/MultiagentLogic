[{
    "id": "001",
    "context": "test_context",
    "question": "test_question",
    "answer": "LP: A, FOL: A, CSP: D, SAT: C",
    "options": [
        "option_test_string_1",
        "option_test_string_2",
        "option_test_string_3",
        "option_test_string_4"
    ],
    "LP": [
      "Predicates:\nCold($x, bool) ::: Is x cold?\nQuiet($x, bool) ::: Is x quiet?\nRed($x, bool) ::: Is x red?\nSmart($x, bool) ::: Is x smart?\nKind($x, bool) ::: Is x kind?\nRough($x, bool) ::: Is x rough?\nRound($x, bool) ::: Is x round?\nFacts:\nCold(Bob, True) ::: Bob is cold.\nQuiet(Bob, True) ::: Bob is quiet.\nRed(Bob, True) ::: Bob is red.\nSmart(Bob, True) ::: Bob is smart.\nKind(Charlie, True) ::: Charlie is kind.\nQuiet(Charlie, True) ::: Charlie is quiet.\nRed(Charlie, True) ::: Charlie is red.\nRough(Charlie, True) ::: Charlie is rough.\nCold(Dave, True) ::: Dave is cold.\nKind(Dave, True) ::: Dave is kind.\nSmart(Dave, True) ::: Dave is smart.\nQuiet(Fiona, True) ::: Fiona is quiet.\nRules:\nQuiet($x, True) && Cold($x, True) >>> Smart($x, True) ::: If something is quiet and cold then it is smart.\nRed($x, True) && Cold($x, True) >>> Round($x, True) ::: Red, cold things are round.\nKind($x, True) && Rough($x, True) >>> Red($x, True) ::: If something is kind and rough then it is red.\nQuiet($x, True) >>> Rough($x, True) ::: All quiet things are rough.\nCold($x, True) && Smart($x, True) >>> Red($x, True) ::: Cold, smart things are red.\nRough($x, True) >>> Cold($x, True) ::: If something is rough then it is cold.\nRed($x, True) >>> Rough($x, True) ::: All red things are rough.\nSmart(Dave, True) && Kind(Dave, True) >>> Quiet(Dave, True) ::: If Dave is smart and Dave is kind then Dave is quiet.\nQuery:\nKind(Charlie, True) ::: Charlie is kind."
    ],
    "FOL": [
      "Predicates:\nCity(x) ::: x is a city.\nIn(x, y) ::: x is in y.\nSameState(x, y) ::: x and y are in the same state.\nPremises:\nCity(billings) ∧ In(billings, montana) ::: Billings is a city in Montana.\nIn(butte, montana) ∧ In(helena, montana) ∧ In(missoula, montana) ::: Montana includes the cities of Butte, Helena, and Missoula.\nCity(whiteSulphurSprings) ∧ City(butte) ∧ SameState(whiteSulphurSprings, butte) ::: White Sulphur Springs and Butte are cities in the same state.\nCity(pierre) ∧ ¬In(pierre, montana) ::: The city of Pierre is not in Montana.\n∀x (In(x, butte) → ¬In(x, pierre)) ::: Any city in Butte is not in Pierre.\nConclusion:\nIn(missoula, montana) ::: Montana is home to the city of Missoula."
    ],
    "CSP": [
      "Domain:\n1: leftmost\n5: rightmost\nVariables:\ngreen_book [IN] [1, 2, 3, 4, 5]\nblue_book [IN] [1, 2, 3, 4, 5]\nwhite_book [IN] [1, 2, 3, 4, 5]\npurple_book [IN] [1, 2, 3, 4, 5]\nyellow_book [IN] [1, 2, 3, 4, 5]\nConstraints:\nblue_book == 4 ::: The blue book is the second from the right.\npurple_book == 2 ::: The purple book is the second from the left.\nyellow_book > blue_book ::: The blue book is to the right of the yellow book.\nwhite_book < yellow_book ::: The white book is to the left of the yellow book.\nAllDifferentConstraint([green_book, blue_book, white_book, purple_book, yellow_book]) ::: All books have different values.\nQuery:\nA) green_book == 2 ::: The green book is the second from the left.\nB) blue_book == 2 ::: The blue book is the second from the left.\nC) white_book == 2 ::: The white book is the second from the left.\nD) purple_book == 2 ::: The purple book is the second from the left.\nE) yellow_book == 2 ::: The yellow book is the second from the left."
    ],
    "SAT": [
      "# Declarations\nchildren = EnumSort([Fred, Juan, Marc, Paul, Nita, Rachel, Trisha])\nlockers = EnumSort([1, 2, 3, 4, 5])\nassigned = Function([children] -> [lockers])\nshared = Function([lockers] -> [bool])\n\n# Constraints\nForAll([c:children], Exists([l:lockers], assigned(c) == l)) ::: each child must be assigned to exactly one locker\nForAll([l:lockers], Or(Exists([c:children], assigned(c) == l), Exists([c1:children, c2:children], And(c1 != c2, assigned(c1) == l, assigned(c2) == l, shared(l))))) ::: Each locker must be assigned to either one or two children\nForAll([l:lockers], Implies(shared(l), Exists([b:children, g:children], And(assigned(b) == l, assigned(g) == l, Or(b == Fred, b == Juan, b == Marc, b == Paul), Or(g == Nita, g == Rachel, g == Trisha))))) ::: Each shared locker must be assigned to one girl and one boy\nExists([l:lockers], And(assigned(Juan) == l, shared(l))) ::: Juan must share a locker\nForAll([l:lockers], Implies(assigned(Rachel) == l, Not(shared(l)))) ::: Rachel cannot share a locker\nForAll([l:lockers], Implies(Or(assigned(Nita) == l, assigned(Trisha) == l), Not(Or(assigned(Nita) == l+1, assigned(Nita) == l-1, assigned(Trisha) == l+1, assigned(Trisha) == l-1)))) ::: Nita's locker cannot be adjacent to Trisha's locker\nassigned(Fred) == 3 ::: Fred must be assigned to locker 3\nAnd(Exists([b:children], And(assigned(b) == 1, Or(b == Fred, b == Juan, b == Marc, b == Paul), Not(shared(1)))), Exists([b:children], And(assigned(b) == 2, Or(b == Fred, b == Juan, b == Marc, b == Paul), Not(shared(2))))) ::: if lockers 1 and 2 are each assigned to one boy and are not shared lockers\n\n# Options\nQuestion ::: If lockers 1 and 2 are each assigned to one boy and are not shared lockers, then locker 4 must be assigned to\nis_sat(assigned(Juan) == 4) ::: (A)\nis_sat(assigned(Paul) == 4) ::: (B)\nis_sat(assigned(Rachel) == 4) ::: (C)\nis_sat(And(assigned(Juan) == 4, assigned(Nita) == 4, shared(4))) ::: (D)\nis_sat(And(assigned(Marc) == 4, assigned(Trisha) == 4, shared(4))) ::: (E)"
    ]
  },
  {
    "id": "002",
    "context": "test_context",
    "question": "test_question",
    "answer": "LP: A, FOL: A, CSP: D, SAT: C",
    "options": [
        "option_test_string_1",
        "option_test_string_2",
        "option_test_string_3",
        "option_test_string_4"
    ],
    "LP": [
      "Predicates:\nCold($x, bool) ::: Is x cold?\nQuiet($x, bool) ::: Is x quiet?\nRed($x, bool) ::: Is x red?\nSmart($x, bool) ::: Is x smart?\nKind($x, bool) ::: Is x kind?\nRough($x, bool) ::: Is x rough?\nRound($x, bool) ::: Is x round?\nFacts:\nCold(Bob, True) ::: Bob is cold.\nQuiet(Bob, True) ::: Bob is quiet.\nRed(Bob, True) ::: Bob is red.\nSmart(Bob, True) ::: Bob is smart.\nKind(Charlie, True) ::: Charlie is kind.\nQuiet(Charlie, True) ::: Charlie is quiet.\nRed(Charlie, True) ::: Charlie is red.\nRough(Charlie, True) ::: Charlie is rough.\nCold(Dave, True) ::: Dave is cold.\nKind(Dave, True) ::: Dave is kind.\nSmart(Dave, True) ::: Dave is smart.\nQuiet(Fiona, True) ::: Fiona is quiet.\nRules:\nQuiet($x, True) && Cold($x, True) >>> Smart($x, True) ::: If something is quiet and cold then it is smart.\nRed($x, True) && Cold($x, True) >>> Round($x, True) ::: Red, cold things are round.\nKind($x, True) && Rough($x, True) >>> Red($x, True) ::: If something is kind and rough then it is red.\nQuiet($x, True) >>> Rough($x, True) ::: All quiet things are rough.\nCold($x, True) && Smart($x, True) >>> Red($x, True) ::: Cold, smart things are red.\nRough($x, True) >>> Cold($x, True) ::: If something is rough then it is cold.\nRed($x, True) >>> Rough($x, True) ::: All red things are rough.\nSmart(Dave, True) && Kind(Dave, True) >>> Quiet(Dave, True) ::: If Dave is smart and Dave is kind then Dave is quiet.\nQuery:\nKind(Charlie, True) ::: Charlie is kind."
    ],
    "FOL": [
      "Predicates:\nCity(x) ::: x is a city.\nIn(x, y) ::: x is in y.\nSameState(x, y) ::: x and y are in the same state.\nPremises:\nCity(billings) ∧ In(billings, montana) ::: Billings is a city in Montana.\nIn(butte, montana) ∧ In(helena, montana) ∧ In(missoula, montana) ::: Montana includes the cities of Butte, Helena, and Missoula.\nCity(whiteSulphurSprings) ∧ City(butte) ∧ SameState(whiteSulphurSprings, butte) ::: White Sulphur Springs and Butte are cities in the same state.\nCity(pierre) ∧ ¬In(pierre, montana) ::: The city of Pierre is not in Montana.\n∀x (In(x, butte) → ¬In(x, pierre)) ::: Any city in Butte is not in Pierre.\nConclusion:\nIn(missoula, montana) ::: Montana is home to the city of Missoula."
    ],
    "CSP": [
      "Domain:\n1: leftmost\n5: rightmost\nVariables:\ngreen_book [IN] [1, 2, 3, 4, 5]\nblue_book [IN] [1, 2, 3, 4, 5]\nwhite_book [IN] [1, 2, 3, 4, 5]\npurple_book [IN] [1, 2, 3, 4, 5]\nyellow_book [IN] [1, 2, 3, 4, 5]\nConstraints:\nblue_book == 4 ::: The blue book is the second from the right.\npurple_book == 2 ::: The purple book is the second from the left.\nyellow_book > blue_book ::: The blue book is to the right of the yellow book.\nwhite_book < yellow_book ::: The white book is to the left of the yellow book.\nAllDifferentConstraint([green_book, blue_book, white_book, purple_book, yellow_book]) ::: All books have different values.\nQuery:\nA) green_book == 2 ::: The green book is the second from the left.\nB) blue_book == 2 ::: The blue book is the second from the left.\nC) white_book == 2 ::: The white book is the second from the left.\nD) purple_book == 2 ::: The purple book is the second from the left.\nE) yellow_book == 2 ::: The yellow book is the second from the left."
    ],
    "SAT": [
      "# Declarations\nchildren = EnumSort([Fred, Juan, Marc, Paul, Nita, Rachel, Trisha])\nlockers = EnumSort([1, 2, 3, 4, 5])\nassigned = Function([children] -> [lockers])\nshared = Function([lockers] -> [bool])\n\n# Constraints\nForAll([c:children], Exists([l:lockers], assigned(c) == l)) ::: each child must be assigned to exactly one locker\nForAll([l:lockers], Or(Exists([c:children], assigned(c) == l), Exists([c1:children, c2:children], And(c1 != c2, assigned(c1) == l, assigned(c2) == l, shared(l))))) ::: Each locker must be assigned to either one or two children\nForAll([l:lockers], Implies(shared(l), Exists([b:children, g:children], And(assigned(b) == l, assigned(g) == l, Or(b == Fred, b == Juan, b == Marc, b == Paul), Or(g == Nita, g == Rachel, g == Trisha))))) ::: Each shared locker must be assigned to one girl and one boy\nExists([l:lockers], And(assigned(Juan) == l, shared(l))) ::: Juan must share a locker\nForAll([l:lockers], Implies(assigned(Rachel) == l, Not(shared(l)))) ::: Rachel cannot share a locker\nForAll([l:lockers], Implies(Or(assigned(Nita) == l, assigned(Trisha) == l), Not(Or(assigned(Nita) == l+1, assigned(Nita) == l-1, assigned(Trisha) == l+1, assigned(Trisha) == l-1)))) ::: Nita's locker cannot be adjacent to Trisha's locker\nassigned(Fred) == 3 ::: Fred must be assigned to locker 3\nAnd(Exists([b:children], And(assigned(b) == 1, Or(b == Fred, b == Juan, b == Marc, b == Paul), Not(shared(1)))), Exists([b:children], And(assigned(b) == 2, Or(b == Fred, b == Juan, b == Marc, b == Paul), Not(shared(2))))) ::: if lockers 1 and 2 are each assigned to one boy and are not shared lockers\n\n# Options\nQuestion ::: If lockers 1 and 2 are each assigned to one boy and are not shared lockers, then locker 4 must be assigned to\nis_sat(assigned(Juan) == 4) ::: (A)\nis_sat(assigned(Paul) == 4) ::: (B)\nis_sat(assigned(Rachel) == 4) ::: (C)\nis_sat(And(assigned(Juan) == 4, assigned(Nita) == 4, shared(4))) ::: (D)\nis_sat(And(assigned(Marc) == 4, assigned(Trisha) == 4, shared(4))) ::: (E)"
    ]
  }]


  