[{
    "id": "001",
    "context": "test_context",
    "question": "test_question",
    "answer": "LP: A, FOL: A, CSP: D, SAT: E",
    "options": [
        "option_test_string_1",
        "option_test_string_2",
        "option_test_string_3",
        "option_test_string_4"
    ],
    "LP": [
      "Predicates:\nCold($x, bool) ::: Is x cold?\nQuiet($x, bool) ::: Is x quiet?\nRed($x, bool) ::: Is x red?\nSmart($x, bool) ::: Is x smart?\nKind($x, bool) ::: Is x kind?\nRough($x, bool) ::: Is x rough?\nRound($x, bool) ::: Is x round?\nFacts:\nCold(Bob, True) ::: Bob is cold.\nQuiet(Bob, True) ::: Bob is quiet.\nRed(Bob, True) ::: Bob is red.\nSmart(Bob, True) ::: Bob is smart.\nKind(Charlie, True) ::: Charlie is kind.\nQuiet(Charlie, True) ::: Charlie is quiet.\nRed(Charlie, True) ::: Charlie is red.\nRough(Charlie, True) ::: Charlie is rough.\nCold(Dave, True) ::: Dave is cold.\nKind(Dave, True) ::: Dave is kind.\nSmart(Dave, True) ::: Dave is smart.\nQuiet(Fiona, True) ::: Fiona is quiet.\nRules:\nQuiet($x, True) && Cold($x, True) >>> Smart($x, True) ::: If something is quiet and cold then it is smart.\nRed($x, True) && Cold($x, True) >>> Round($x, True) ::: Red, cold things are round.\nKind($x, True) && Rough($x, True) >>> Red($x, True) ::: If something is kind and rough then it is red.\nQuiet($x, True) >>> Rough($x, True) ::: All quiet things are rough.\nCold($x, True) && Smart($x, True) >>> Red($x, True) ::: Cold, smart things are red.\nRough($x, True) >>> Cold($x, True) ::: If something is rough then it is cold.\nRed($x, True) >>> Rough($x, True) ::: All red things are rough.\nSmart(Dave, True) && Kind(Dave, True) >>> Quiet(Dave, True) ::: If Dave is smart and Dave is kind then Dave is quiet.\nQuery:\nKind(Charlie, True) ::: Charlie is kind."
    ],
    "FOL": [
      "Predicates:\nPerform(x) ::: x performs in school talent shows often.\nAttend(x) ::: x attends and is very engaged with school events.\nInactive(x) ::: x is an inactive and disinterested member of their community.\nChaperone(x) ::: x chaperones high school dances.\nStudent(x) ::: x is a student who attends the school.\nYoung(x) ::: x is a young child or teenager who wishes to further their academic career and educational opportunities.\nPremises:\n∀x (Perform(x) → Attend(x)) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x (Perform(x) ⊕ Inactive(x)) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x (Inactive(x) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x (Young(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n(Attend(bonnie) ∧ Student(bonnie)) ⊕ ¬(Attend(bonnie) ∨ Student(bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\nConclusion:\n((Young(bonnie) ∧ Chaperone(bonnie)) ⊕ ¬(Young(bonnie) ∨ Chaperone(bonnie))) → (Student(bonnie) ⊕ Inactive(bonnie)) ::: If Bonnie is either both a young child or teenager who wishes to further her academic career and educational opportunities and chaperones high school dances or neither is a young child nor teenager who wishes to further her academic career and educational opportunities, then Bonnie is either a student who attends the school or is an inactive and disinterested member of the community."
    ],
    "CSP": [
      "Domain:\n1: leftmost\n5: rightmost\nVariables:\ngreen_book [IN] [1, 2, 3, 4, 5]\nblue_book [IN] [1, 2, 3, 4, 5]\nwhite_book [IN] [1, 2, 3, 4, 5]\npurple_book [IN] [1, 2, 3, 4, 5]\nyellow_book [IN] [1, 2, 3, 4, 5]\nConstraints:\nblue_book == 4 ::: The blue book is the second from the right.\npurple_book == 2 ::: The purple book is the second from the left.\nyellow_book > blue_book ::: The blue book is to the right of the yellow book.\nwhite_book < yellow_book ::: The white book is to the left of the yellow book.\nAllDifferentConstraint([green_book, blue_book, white_book, purple_book, yellow_book]) ::: All books have different values.\nQuery:\nA) green_book == 2 ::: The green book is the second from the left.\nB) blue_book == 2 ::: The blue book is the second from the left.\nC) white_book == 2 ::: The white book is the second from the left.\nD) purple_book == 2 ::: The purple book is the second from the left.\nE) yellow_book == 2 ::: The yellow book is the second from the left."
    ],
    "SAT": [
      "# Declarations\nchildren = EnumSort([Fred, Juan, Marc, Paul, Nita, Rachel, Trisha])\nlockers = EnumSort([1, 2, 3, 4, 5])\nassigned = Function([children] -> [lockers])\n\n# Constraints\nForAll([l:lockers], Or(Count([c:children], assigned(c) == l) == 1, And(Count([c:children], assigned(c) == l) == 2, Exists([b:boys, g:girls], And(assigned(b) == l, assigned(g) == l))))) ::: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker\nExists([c:children], assigned(Juan) == assigned(c)) ::: Juan must share a locker\nForAll([c:children], assigned(Rachel) != assigned(c)) ::: Rachel cannot share a locker\nForAll([l:lockers], Implies(assigned(Nita) == l, And(assigned(Trisha) != l, assigned(Trisha) != l+1, assigned(Trisha) != l-1))) ::: Nita's locker cannot be adjacent to Trisha's locker\nassigned(Fred) == 3 ::: Fred must be assigned to locker 3\n\n# Options\nQuestion ::: Which one of the following is a complete and accurate list of the children who must be among those assigned to shared lockers?\nis_accurate_list([Exists([c:children], assigned(Fred) == assigned(c)), Exists([c:children], assigned(Juan) == assigned(c))]) ::: (A)\nis_accurate_list([Exists([c:children], assigned(Juan) == assigned(c)), Exists([c:children], assigned(Paul) == assigned(c))]) ::: (B)\nis_accurate_list([Exists([c:children], assigned(Juan) == assigned(c)), Exists([c:children], assigned(Marc) == assigned(c)), Exists([c:children], assigned(Paul) == assigned(c))]) ::: (C)\nis_accurate_list([Exists([c:children], assigned(Juan) == assigned(c)), Exists([c:children], assigned(Marc) == assigned(c)), Exists([c:children], assigned(Trisha) == assigned(c))]) ::: (D)\nis_accurate_list([Exists([c:children], assigned(Juan) == assigned(c)), Exists([c:children], assigned(Nita) == assigned(c)), Exists([c:children], assigned(Trisha) == assigned(c))]) ::: (E)"
    ]
  },
  {
    "id": "002",
    "context": "test_context",
    "question": "test_question",
    "answer": "LP: A, FOL: A, CSP: D, SAT: E",
    "options": [
        "option_test_string_1",
        "option_test_string_2",
        "option_test_string_3",
        "option_test_string_4"
    ],
    "LP": [
      "Predicates:\nCold($x, bool) ::: Is x cold?\nQuiet($x, bool) ::: Is x quiet?\nRed($x, bool) ::: Is x red?\nSmart($x, bool) ::: Is x smart?\nKind($x, bool) ::: Is x kind?\nRough($x, bool) ::: Is x rough?\nRound($x, bool) ::: Is x round?\nFacts:\nCold(Bob, True) ::: Bob is cold.\nQuiet(Bob, True) ::: Bob is quiet.\nRed(Bob, True) ::: Bob is red.\nSmart(Bob, True) ::: Bob is smart.\nKind(Charlie, True) ::: Charlie is kind.\nQuiet(Charlie, True) ::: Charlie is quiet.\nRed(Charlie, True) ::: Charlie is red.\nRough(Charlie, True) ::: Charlie is rough.\nCold(Dave, True) ::: Dave is cold.\nKind(Dave, True) ::: Dave is kind.\nSmart(Dave, True) ::: Dave is smart.\nQuiet(Fiona, True) ::: Fiona is quiet.\nRules:\nQuiet($x, True) && Cold($x, True) >>> Smart($x, True) ::: If something is quiet and cold then it is smart.\nRed($x, True) && Cold($x, True) >>> Round($x, True) ::: Red, cold things are round.\nKind($x, True) && Rough($x, True) >>> Red($x, True) ::: If something is kind and rough then it is red.\nQuiet($x, True) >>> Rough($x, True) ::: All quiet things are rough.\nCold($x, True) && Smart($x, True) >>> Red($x, True) ::: Cold, smart things are red.\nRough($x, True) >>> Cold($x, True) ::: If something is rough then it is cold.\nRed($x, True) >>> Rough($x, True) ::: All red things are rough.\nSmart(Dave, True) && Kind(Dave, True) >>> Quiet(Dave, True) ::: If Dave is smart and Dave is kind then Dave is quiet.\nQuery:\nKind(Charlie, True) ::: Charlie is kind."
    ],
    "FOL": [
      "Predicates:\nPerform(x) ::: x performs in school talent shows often.\nAttend(x) ::: x attends and is very engaged with school events.\nInactive(x) ::: x is an inactive and disinterested member of their community.\nChaperone(x) ::: x chaperones high school dances.\nStudent(x) ::: x is a student who attends the school.\nYoung(x) ::: x is a young child or teenager who wishes to further their academic career and educational opportunities.\nPremises:\n∀x (Perform(x) → Attend(x)) ::: If people perform in school talent shows often, then they attend and are very engaged with school events.\n∀x (Perform(x) ⊕ Inactive(x)) ::: People either perform in school talent shows often or are inactive and disinterested members of their community.\n∀x (Chaperone(x) → ¬Student(x)) ::: If people chaperone high school dances, then they are not students who attend the school.\n∀x (Inactive(x) → Chaperone(x)) ::: All people who are inactive and disinterested members of their community chaperone high school dances.\n∀x (Young(x) → Student(x)) ::: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.\n(Attend(bonnie) ∧ Student(bonnie)) ⊕ ¬(Attend(bonnie) ∨ Student(bonnie)) ::: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.\nConclusion:\n((Young(bonnie) ∧ Chaperone(bonnie)) ⊕ ¬(Young(bonnie) ∨ Chaperone(bonnie))) → (Student(bonnie) ⊕ Inactive(bonnie)) ::: If Bonnie is either both a young child or teenager who wishes to further her academic career and educational opportunities and chaperones high school dances or neither is a young child nor teenager who wishes to further her academic career and educational opportunities, then Bonnie is either a student who attends the school or is an inactive and disinterested member of the community."
    ],
    "CSP": [
      "Domain:\n1: leftmost\n5: rightmost\nVariables:\ngreen_book [IN] [1, 2, 3, 4, 5]\nblue_book [IN] [1, 2, 3, 4, 5]\nwhite_book [IN] [1, 2, 3, 4, 5]\npurple_book [IN] [1, 2, 3, 4, 5]\nyellow_book [IN] [1, 2, 3, 4, 5]\nConstraints:\nblue_book == 4 ::: The blue book is the second from the right.\npurple_book == 2 ::: The purple book is the second from the left.\nyellow_book > blue_book ::: The blue book is to the right of the yellow book.\nwhite_book < yellow_book ::: The white book is to the left of the yellow book.\nAllDifferentConstraint([green_book, blue_book, white_book, purple_book, yellow_book]) ::: All books have different values.\nQuery:\nA) green_book == 2 ::: The green book is the second from the left.\nB) blue_book == 2 ::: The blue book is the second from the left.\nC) white_book == 2 ::: The white book is the second from the left.\nD) purple_book == 2 ::: The purple book is the second from the left.\nE) yellow_book == 2 ::: The yellow book is the second from the left."
    ],
    "SAT": [
      "# Declarations\nchildren = EnumSort([Fred, Juan, Marc, Paul, Nita, Rachel, Trisha])\nlockers = EnumSort([1, 2, 3, 4, 5])\nassigned = Function([children] -> [lockers])\n\n# Constraints\nForAll([l:lockers], Or(Count([c:children], assigned(c) == l) == 1, And(Count([c:children], assigned(c) == l) == 2, Exists([b:boys, g:girls], And(assigned(b) == l, assigned(g) == l))))) ::: Each locker must be assigned to either one or two children, and each child must be assigned to exactly one locker\nExists([c:children], assigned(Juan) == assigned(c)) ::: Juan must share a locker\nForAll([c:children], assigned(Rachel) != assigned(c)) ::: Rachel cannot share a locker\nForAll([l:lockers], Implies(assigned(Nita) == l, And(assigned(Trisha) != l, assigned(Trisha) != l+1, assigned(Trisha) != l-1))) ::: Nita's locker cannot be adjacent to Trisha's locker\nassigned(Fred) == 3 ::: Fred must be assigned to locker 3\n\n# Options\nQuestion ::: Which one of the following is a complete and accurate list of the children who must be among those assigned to shared lockers?\nis_accurate_list([Exists([c:children], assigned(Fred) == assigned(c)), Exists([c:children], assigned(Juan) == assigned(c))]) ::: (A)\nis_accurate_list([Exists([c:children], assigned(Juan) == assigned(c)), Exists([c:children], assigned(Paul) == assigned(c))]) ::: (B)\nis_accurate_list([Exists([c:children], assigned(Juan) == assigned(c)), Exists([c:children], assigned(Marc) == assigned(c)), Exists([c:children], assigned(Paul) == assigned(c))]) ::: (C)\nis_accurate_list([Exists([c:children], assigned(Juan) == assigned(c)), Exists([c:children], assigned(Marc) == assigned(c)), Exists([c:children], assigned(Trisha) == assigned(c))]) ::: (D)\nis_accurate_list([Exists([c:children], assigned(Juan) == assigned(c)), Exists([c:children], assigned(Nita) == assigned(c)), Exists([c:children], assigned(Trisha) == assigned(c))]) ::: (E)"
    ]
  }]


  